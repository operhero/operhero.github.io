I"al<h1 id="下载demo">下载demo</h1>
<p>克隆github项目</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone git@github.com:Azure/DotNetty.git
</code></pre></div></div>

<h1 id="handler与childhandler">Handler与ChildHandler</h1>
<ul>
  <li>Handler方法由AbstractBootstrap提供，在初始化时执行</li>
  <li>ChildHandler方法由ServerBootstrap提供，而ServerBootstrap继承自AbstractBootstrap，在客户端成功connect后才执行，目的是监听已经连接的客户端的Channel的动作和状态</li>
</ul>

<h1 id="abstractbootstrap的小技巧">AbstractBootstrap的小技巧</h1>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">AbstractBootstrap</span><span class="p">&lt;</span><span class="n">TBootstrap</span><span class="p">,</span> <span class="n">TChannel</span><span class="p">&gt;</span>
        <span class="k">where</span> <span class="n">TBootstrap</span> <span class="p">:</span> <span class="n">AbstractBootstrap</span><span class="p">&lt;</span><span class="n">TBootstrap</span><span class="p">,</span> <span class="n">TChannel</span><span class="p">&gt;</span>
        <span class="k">where</span> <span class="n">TChannel</span> <span class="p">:</span> <span class="n">IChannel</span>
</code></pre></div></div>

<p>虚基类中定义的所有方法，都返回IBootstrap，如：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">virtual</span> <span class="n">TBootstrap</span> <span class="nf">Group</span><span class="p">(</span><span class="n">IEventLoopGroup</span> <span class="k">group</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Contract</span><span class="p">.</span><span class="nf">Requires</span><span class="p">(</span><span class="k">group</span> <span class="p">!=</span> <span class="k">null</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="k">group</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="s">"group has already been set."</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="k">group</span> <span class="p">=</span> <span class="k">group</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">TBootstrap</span><span class="p">)</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样的好处，是让继承类的对象能同时调用虚基类方法和子类方法</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">bootstrap</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ServerBootstrap</span><span class="p">();</span>
<span class="n">bootstrap</span>
  <span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="n">bossGroup</span><span class="p">,</span> <span class="n">workerGroup</span><span class="p">)</span>
  <span class="p">.</span><span class="n">Channel</span><span class="p">&lt;</span><span class="n">TcpServerSocketChannel</span><span class="p">&gt;()</span>
  <span class="p">.</span><span class="nf">Option</span><span class="p">(</span><span class="n">ChannelOption</span><span class="p">.</span><span class="n">SoBacklog</span><span class="p">,</span> <span class="m">100</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">Handler</span><span class="p">(</span><span class="k">new</span> <span class="nf">LoggingHandler</span><span class="p">(</span><span class="s">"LSTN"</span><span class="p">))</span>
  <span class="p">.</span><span class="nf">ChildHandler</span><span class="p">(</span><span class="k">new</span> <span class="n">ActionChannelInitializer</span><span class="p">&lt;</span><span class="n">ISocketChannel</span><span class="p">&gt;(</span><span class="n">channel</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
      <span class="n">IChannelPipeline</span> <span class="n">pipeline</span> <span class="p">=</span> <span class="n">channel</span><span class="p">.</span><span class="n">Pipeline</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tlsCertificate</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">pipeline</span><span class="p">.</span><span class="nf">AddLast</span><span class="p">(</span><span class="n">TlsHandler</span><span class="p">.</span><span class="nf">Server</span><span class="p">(</span><span class="n">tlsCertificate</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="n">pipeline</span><span class="p">.</span><span class="nf">AddLast</span><span class="p">(</span><span class="k">new</span> <span class="nf">LoggingHandler</span><span class="p">(</span><span class="s">"CONN"</span><span class="p">));</span>
      <span class="n">pipeline</span><span class="p">.</span><span class="nf">AddLast</span><span class="p">(</span><span class="k">new</span> <span class="nf">NumberEncoder</span><span class="p">(),</span> <span class="k">new</span> <span class="nf">BigIntegerDecoder</span><span class="p">(),</span> <span class="k">new</span> <span class="nf">FactorialServerHandler</span><span class="p">());</span>
  <span class="p">}));</span>
</code></pre></div></div>

<p>Group、Channel、Option、Handler都属于AbstractBootstrap提供的方法，ChildHandler由ServerBootstrap提供</p>

<p>这种技巧叫做Curiously recurring template pattern，参考<a href="https://www.zhihu.com/question/27421302/answer/36573889?utm_source=qq&amp;utm_medium=social&amp;utm_oi=42155812847616">知乎</a></p>

<h1 id="reactor模型">Reactor模型</h1>
<p>Reactor 模型是基于事件驱动的，有单线程模型、多线程模型和主从多线程模型：</p>

<h3 id="单线程模型">单线程模型</h3>
<p><img src="/images/dotnetty/1.png" alt="单线程模型" />
单线程模型指的是所有的 I/O 操作都是在同一个 NIO 线程上面完成, 由于 Reactor 模型使用的是 NIO,I/O 操作不会导致阻塞, 理论上一个线程可以独立处理所有 I/O 相关的操作</p>

<p>从架构层面看, 一个 NIO 线程确实可以完成其承担的职责, 例如通过 Acceptor 类接收客户端的 TCP 连接请求, 链路建立成功后通过 Dispatch 将对应的 ByteBuffer 派发到指定的 Handler 上进行消息处理并响应客户端</p>

<p>但一个 NIO 线程同时处理成百上千的链路, 性能上无法支撑, 即便 NIO 线程的 CPU 符合达到 100%, 也无法满足海量消息处理当负荷后处理速度变慢, 导致大量客户端连接超时, 最终导致大量消息积压和超时且一旦 NIO 线程发生故障则会导致整个通信模块不可用</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">bootstrap</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ServerBootstrap</span><span class="p">();</span>
<span class="n">bootstrap</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span> <span class="k">new</span> <span class="nf">MultithreadEventLoopGroup</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="多线程模型">多线程模型</h3>
<p><img src="/images/dotnetty/2.png" alt="多线程模型" />
多线程模型与单线程模型最大区别就是有一组 NIO 线程处理 I/O 操作</p>

<p>有专门一个 NIO 线程 (Acceptor) 用于接收客户端 TCP 连接请求, 读写 I/O 操作由一个 NIO 线程池负责</p>

<p>一个 NIO 线程可以同时处理 N 条链路, 但一个链路只对应一个 NIO 线程, 防止并发操作问题</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">bossGroup</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MultithreadEventLoopGroup</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">workerGroup</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MultithreadEventLoopGroup</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">bootstrap</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ServerBootstrap</span><span class="p">();</span>
<span class="n">bootstrap</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="n">bossGroup</span><span class="p">,</span> <span class="n">workerGroup</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="主从多线程模型">主从多线程模型</h3>
<p><img src="/images/dotnetty/3.png" alt="主从线程模型" />
绝大多数场景下, 多线程模型都可以满足性能需求, 但是再极个别特殊场景中, 一个 NIO 线程处理客户端连接请求可能会存在性能问题, 例如百万客户端连接, 在这种情况下单独一个 Acceptor 线程可能会存在性能问题, 为了解决性能问题, 产生了主从多线程模型</p>

<p>它的特点是: 服务端用于接收客户端连接的不再是单独一个 NIO 线程, 而是一个独立的 NIO 线程池</p>

<p>Acceptor 接收到客户端 TCP 连接请求处理完成后(可能包含接入认证等), 将新创建的 SocketChannel 注册到 I/O 线程池的某个线程上, 由它负责 SocketChannel 的读写和编解码工作</p>

<p>Acceptor 线程池仅仅只用于客户端的登陆握手和安全认证, 由 I/O 线程负责后续的 I/O 操作</p>

<blockquote>
  <p>DotNetty 没有使用主从多线程模型, 服务器端的 ServerSocketChannel 只绑定到了 bossGroup 中的一个线程, 因此在调用 Java NIO 的 Selector.select 处理客户端的连接请求时, 实际上是在一个线程中的, 所以对只有一个服务的应用来说, bossGroup 设置多个线程是没有什么作用的, 反而还会造成资源浪费</p>
</blockquote>

<h1 id="multithreadeventloopgroup">MultithreadEventLoopGroup</h1>
<p>MultithreadEventLoopGroup是上节提到的线程池实现。包含一个IEventLoop数组，通过GetNext()方法顺序获取一个IEventLoop，对外提供IEventExecutor功能</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">override</span> <span class="n">IEventExecutor</span> <span class="nf">GetNext</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">id</span> <span class="p">=</span> <span class="n">Interlocked</span><span class="p">.</span><span class="nf">Increment</span><span class="p">(</span><span class="k">ref</span> <span class="k">this</span><span class="p">.</span><span class="n">requestId</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">eventLoops</span><span class="p">[</span><span class="n">Math</span><span class="p">.</span><span class="nf">Abs</span><span class="p">(</span><span class="n">id</span> <span class="p">%</span> <span class="k">this</span><span class="p">.</span><span class="n">eventLoops</span><span class="p">.</span><span class="n">Length</span><span class="p">)];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>先上两张类图：
<img src="/images/dotnetty/4.png" alt="MultithreadEventLoopGroup" />
<img src="/images/dotnetty/5.png" alt="SingleThreadEventLoop" /></p>

<p>Dotnetty中没有NioEventLoopGroup类和NioEventLoop类。</p>

<p>这里要说明的是，SingleThreadEventLoop是MultithreadEventLoopGroup中IEventLoop一种默认实现方式，MultithreadEventLoopGroup实际上包含SingleThreadEventLoop数组</p>

<p>另外值得注意的一点是，<strong>EventLoop继承自EventLoopGroup！！！</strong></p>

<p>上节例子中使用MultithreadEventLoopGroup，他有三种缺省构造方法：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">/// &lt;summary&gt;Creates a new instance of &lt;see cref="MultithreadEventLoopGroup"/&gt;.&lt;/summary&gt;</span>
<span class="k">public</span> <span class="nf">MultithreadEventLoopGroup</span><span class="p">()</span>
    <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="n">DefaultEventLoopFactory</span><span class="p">,</span> <span class="n">DefaultEventLoopThreadCount</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="c1">/// &lt;summary&gt;Creates a new instance of &lt;see cref="MultithreadEventLoopGroup"/&gt;.&lt;/summary&gt;</span>
<span class="k">public</span> <span class="nf">MultithreadEventLoopGroup</span><span class="p">(</span><span class="kt">int</span> <span class="n">eventLoopCount</span><span class="p">)</span>
    <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="n">DefaultEventLoopFactory</span><span class="p">,</span> <span class="n">eventLoopCount</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="c1">/// &lt;summary&gt;Creates a new instance of &lt;see cref="MultithreadEventLoopGroup"/&gt;.&lt;/summary&gt;</span>
<span class="k">public</span> <span class="nf">MultithreadEventLoopGroup</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">IEventLoopGroup</span><span class="p">,</span> <span class="n">IEventLoop</span><span class="p">&gt;</span> <span class="n">eventLoopFactory</span><span class="p">)</span>
    <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="n">eventLoopFactory</span><span class="p">,</span> <span class="n">DefaultEventLoopThreadCount</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<p>缺省默认值：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="n">DefaultEventLoopThreadCount</span> <span class="p">=</span> <span class="n">Environment</span><span class="p">.</span><span class="n">ProcessorCount</span> <span class="p">*</span> <span class="m">2</span><span class="p">;</span>
<span class="k">static</span> <span class="k">readonly</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">IEventLoopGroup</span><span class="p">,</span> <span class="n">IEventLoop</span><span class="p">&gt;</span> <span class="n">DefaultEventLoopFactory</span> <span class="p">=</span> <span class="k">group</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nf">SingleThreadEventLoop</span><span class="p">(</span><span class="k">group</span><span class="p">);</span>
</code></pre></div></div>
<blockquote>
  <p>默认生成2倍cpu数量的线程</p>
</blockquote>

<blockquote>
  <p>默认产生的IEventLoop的实现类为SingleThreadEventLoop</p>
</blockquote>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="nf">MultithreadEventLoopGroup</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">IEventLoopGroup</span><span class="p">,</span> <span class="n">IEventLoop</span><span class="p">&gt;</span> <span class="n">eventLoopFactory</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eventLoopCount</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">eventLoops</span> <span class="p">=</span> <span class="k">new</span> <span class="n">IEventLoop</span><span class="p">[</span><span class="n">eventLoopCount</span><span class="p">];</span>
    <span class="kt">var</span> <span class="n">terminationTasks</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Task</span><span class="p">[</span><span class="n">eventLoopCount</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">eventLoopCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">IEventLoop</span> <span class="n">eventLoop</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">success</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="n">eventLoop</span> <span class="p">=</span> <span class="nf">eventLoopFactory</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
            <span class="n">success</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="s">"failed to create a child event loop."</span><span class="p">,</span> <span class="n">ex</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">finally</span>
        <span class="p">{</span>
            <span class="c1">// 如果创建失败，销毁之前的eventLoop</span>
            <span class="k">if</span> <span class="p">(!</span><span class="n">success</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span>
                        <span class="k">this</span><span class="p">.</span><span class="n">eventLoops</span>
                            <span class="p">.</span><span class="nf">Take</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">loop</span> <span class="p">=&gt;</span> <span class="n">loop</span><span class="p">.</span><span class="nf">ShutdownGracefullyAsync</span><span class="p">()))</span>
                    <span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">this</span><span class="p">.</span><span class="n">eventLoops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">eventLoop</span><span class="p">;</span>
        <span class="n">terminationTasks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">eventLoop</span><span class="p">.</span><span class="n">TerminationCompletion</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="n">TerminationCompletion</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">terminationTasks</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看到，SingleThreadEventLoop是实际产生IEventLoop的类。</p>

<p>SingleThreadEventLoop从名字看是一个执行任务的线程，继承自SingleThreadEventExecutor
注意SingleThreadEventLoop的GetNext()方法：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">new</span> <span class="n">IEventLoop</span> <span class="nf">GetNext</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">;</span>
</code></pre></div></div>
<p>以及构造函数：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">protected</span> <span class="nf">SingleThreadEventExecutor</span><span class="p">(</span><span class="n">IEventExecutorGroup</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">string</span> <span class="n">threadName</span><span class="p">,</span> <span class="n">TimeSpan</span> <span class="n">breakoutInterval</span><span class="p">,</span> <span class="n">IQueue</span><span class="p">&lt;</span><span class="n">IRunnable</span><span class="p">&gt;</span> <span class="n">taskQueue</span><span class="p">)</span>
            <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">terminationCompletionSource</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TaskCompletionSource</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="n">taskQueue</span> <span class="p">=</span> <span class="n">taskQueue</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">preciseBreakoutInterval</span> <span class="p">=</span> <span class="n">PreciseTimeSpan</span><span class="p">.</span><span class="nf">FromTimeSpan</span><span class="p">(</span><span class="n">breakoutInterval</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="n">scheduler</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ExecutorTaskScheduler</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="n">thread</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Loop</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="nf">IsNullOrEmpty</span><span class="p">(</span><span class="n">threadName</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">thread</span><span class="p">.</span><span class="n">Name</span> <span class="p">=</span> <span class="n">DefaultWorkerThreadName</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">thread</span><span class="p">.</span><span class="n">Name</span> <span class="p">=</span> <span class="n">threadName</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="n">thread</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其本质是声明了一个线程，执行Loop方法：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Loop</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nf">SetCurrentExecutor</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

  <span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(</span>
      <span class="p">()</span> <span class="p">=&gt;</span>
      <span class="p">{</span>
          <span class="k">try</span>
          <span class="p">{</span>
              <span class="n">Interlocked</span><span class="p">.</span><span class="nf">CompareExchange</span><span class="p">(</span><span class="k">ref</span> <span class="k">this</span><span class="p">.</span><span class="n">executionState</span><span class="p">,</span> <span class="n">ST_STARTED</span><span class="p">,</span> <span class="n">ST_NOT_STARTED</span><span class="p">);</span>
              <span class="k">while</span> <span class="p">(!</span><span class="k">this</span><span class="p">.</span><span class="nf">ConfirmShutdown</span><span class="p">())</span>
              <span class="p">{</span>
                  <span class="k">this</span><span class="p">.</span><span class="nf">RunAllTasks</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">preciseBreakoutInterval</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">this</span><span class="p">.</span><span class="nf">CleanupAndTerminate</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">Logger</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="s">"{}: execution loop failed"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">thread</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">ex</span><span class="p">);</span>
              <span class="k">this</span><span class="p">.</span><span class="n">executionState</span> <span class="p">=</span> <span class="n">ST_TERMINATED</span><span class="p">;</span>
              <span class="k">this</span><span class="p">.</span><span class="n">terminationCompletionSource</span><span class="p">.</span><span class="nf">TrySetException</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">},</span>
      <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">,</span>
      <span class="n">TaskCreationOptions</span><span class="p">.</span><span class="n">None</span><span class="p">,</span>
      <span class="k">this</span><span class="p">.</span><span class="n">scheduler</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
:ET